fsurface <- fsurface$multiply(eaf)$multiply(thf)
# convert <- function(x) {(x * 1000 / 60) ^ -1} # converts km/h to min/m
fsurface <- fsurface$expression(
c('(x * 1000 / 60) ** -1'),
list('x'= fsurface$select(list(0)))
)
# Paint the input points, essentially converting them to a raster.
# Theoretically this will merge any points that fall within the same pixel (of the resulting 30-arc-second resolution).
sources <- black$paint(school, 1)
sources <- sources$updateMask(sources)
# Compute the min cost path distance map, with a horizon of 1500 km.
# This can be reduced for high-latitude areas and/or to shorten processing time.
distance <- fsurface$cumulativeCost(sources, 400000)  # The function accepts meters rather than km.
distance <- ee$Image(distance)$toInt() # Here we convert the output to integer to make the output .tif smaller (and the code more likely to run successfully).
distance <- distance$clip(peru)$reproject("EPSG:4326")
# Final Map
viz <- list(
min = 0,
max = 600,
palette = cpt(pal = 'grass_bcyr',n = 5,rev = T)
)
Map$addLayer(distance,viz,'accessibility') +
Map$addLayer(fsurface$clip(peru),viz,'friction') +
Map$addLayer(school)
Map$addLayer(distance,viz,'accessibility') +
Map$addLayer(fsurface$clip(peru),viz,'friction')
distance
fsurface
peru
# Final Map
viz <- list(
min = 0,
max = 600,
palette = cpt(pal = 'grass_bcyr',n = 5,rev = T)
)
Map$addLayer(distance,viz,'accessibility') +
Map$addLayer(fsurface$clip(peru),viz,'friction')
inputPoints <- ee$FeatureCollection('users/edgarmanrique30/Peru_geometry/eess_20190319')
# Paint the input points, essentially converting them to a raster.
# Theoretically this will merge any points that fall within the same pixel (of the resulting 30-arc-second resolution).
sources <- black$paint(inputPoints, 1)
sources <- sources$updateMask(sources)
# Compute the min cost path distance map, with a horizon of 1500 km.
# This can be reduced for high-latitude areas and/or to shorten processing time.
distance <- fsurface$cumulativeCost(sources, 400000)  # The function accepts meters rather than km.
distance <- ee$Image(distance)$toInt() # Here we convert the output to integer to make the output .tif smaller (and the code more likely to run successfully).
distance <- distance$clip(peru)$reproject("EPSG:4326")
# Final Map
viz <- list(
min = 0,
max = 600,
palette = cpt(pal = 'grass_bcyr',n = 5,rev = T)
)
Map$addLayer(distance,viz,'accessibility') +
Map$addLayer(fsurface$clip(peru),viz,'friction')
distance <- distance$clip(peru)
# Final Map
viz <- list(
min = 0,
max = 600,
palette = cpt(pal = 'grass_bcyr',n = 5,rev = T)
)
Map$addLayer(distance,viz,'accessibility') +
Map$addLayer(fsurface$clip(peru),viz,'friction')
# Paint the input points, essentially converting them to a raster.
# Theoretically this will merge any points that fall within the same pixel (of the resulting 30-arc-second resolution).
sources <- black$paint(inputPoints, 1)
sources <- sources$updateMask(sources)
# Compute the min cost path distance map, with a horizon of 1500 km.
# This can be reduced for high-latitude areas and/or to shorten processing time.
distance <- fsurface$cumulativeCost(sources, 400000)  # The function accepts meters rather than km.
distance <- ee$Image(distance)$toInt() # Here we convert the output to integer to make the output .tif smaller (and the code more likely to run successfully).
distance <- distance$clip(peru)
# Final Map
viz <- list(
min = 0,
max = 600,
palette = cpt(pal = 'grass_bcyr',n = 5,rev = T)
)
Map$addLayer(distance,viz,'accessibility') +
Map$addLayer(fsurface$clip(peru),viz,'friction')
# Final Map
viz <- list(
min = 0,
max = 600,
palette = c("#dd554b","#e2b43f","#dbda92","#60b27f","#4866c9")
)
Map$addLayer(distance,viz,'accessibility') +
Map$addLayer(fsurface$clip(peru),viz,'friction')
# Creating Natural protected areas layer
anp <- black$paint(anp, c(1))$
clip(peru$geometry())
Map$addLayer(anp)
anp   <- ee$FeatureCollection('users/edgarmanrique30/Peru_geometry/ANP-Nacional')
# Creating Natural protected areas layer
anp <- black$paint(anp, c(1))$
clip(peru$geometry())
#Remapping values to 0.2 km/h of Natural protected areas to multiply Landcover speed
anp <- anp$remap(list(0,1),list(1,0.2))
landcspeed <- landcspeed$multiply(anp) # Multiplying Landcover speed by 0.2 on Natural protected areas
Map$addLayer(landcspeed)
anp   <- ee$FeatureCollection('users/edgarmanrique30/Peru_geometry/ANP-Nacional')
# Creating Natural protected areas layer
anp <- black$paint(anp, c(0))$
clip(peru$geometry())
Map$addLayer(anp)
#Remapping values to 0.2 km/h of Natural protected areas to multiply Landcover speed
anp <- anp$remap(list(0,1),list(1,0.2))
landcspeed <- landcspeed$multiply(anp) # Multiplying Landcover speed by 0.2 on Natural protected areas
Map$addLayer(landcspeed)
anp   <- ee$FeatureCollection('users/edgarmanrique30/Peru_geometry/ANP-Nacional')
inputPoints <- ee$FeatureCollection('users/edgarmanrique30/Peru_geometry/eess_20190319')
# Creating Natural protected areas layer
anp <- black$paint(anp, 1)$
clip(peru$geometry())
#Remapping values to 0.2 km/h of Natural protected areas to multiply Landcover speed
anp <- anp$remap(list(0,1),list(1,0.2))
landcspeed <- landcspeed$multiply(anp) # Multiplying Landcover speed by 0.2 on Natural protected areas
landcspeed <- landcspeed$toDouble()$select(list(0),list("speed"))
Map$addLayer(landcspeed)
rios <- rios$toDouble()$select(list(0),list("speed"))
vias_nac <- vias_nac$toDouble()$select(list(0),list("speed")) # unifying the band name
vias_dep <- vias_dep$toDouble()$select(list(0),list("speed")) # unifying the band name
vias_vec <- vias_vec$toDouble()$select(list(0),list("speed")) # unifying the band name
# Mergging all layers into a collection
collection <- ee$ImageCollection(
list(landcspeed,
rios,
vias_nac,
vias_dep,
vias_vec
)
)
fsurface <- collection$max() # Calculating the maximum value of speed on a single pixel
Map$addLayer(fsurface)
Map$addLayer(landcspeed)
Map$addLayer(landcspeed,visParams = list(min=0,max=1))
# Preparing dataset
peru  <- ee$FeatureCollection('users/edgarmanrique30/Peru_geometry/Limite_departamental')
dem   <- ee$Image('USGS/SRTMGL1_003')
landc <- ee$ImageCollection('MODIS/006/MCD12Q1')
vias_dep <- ee$FeatureCollection('users/edgarmanrique30/Peru_geometry/red_vial_departamental_dic16')
vias_nac <- ee$FeatureCollection('users/edgarmanrique30/Peru_geometry/red_vial_nacional_dic16')
vias_vec <- ee$FeatureCollection('users/edgarmanrique30/Peru_geometry/red_vial_vecinal_dic16')
rios  <- ee$Image('WWF/HydroSHEDS/15ACC')
anp   <- ee$FeatureCollection('users/edgarmanrique30/Peru_geometry/ANP-Nacional')
inputPoints <- ee$FeatureCollection('users/edgarmanrique30/Peru_geometry/eess_20190319')
# Construccion our friction surface
# Topographyc variables
dem <- dem$clip(peru)
slope <- ee$Terrain$slope(dem)
Map$addLayer(slope)
# LandCover for Peru
landc <- landc$select("LC_Type1")$
filterDate("2017-01-01","2017-12-31")$
median()$
clip(peru)
Map.addLayer(landc)
# Preparing dataset
peru  <- ee$FeatureCollection('users/edgarmanrique30/Peru_geometry/Limite_departamental')
dem   <- ee$Image('USGS/SRTMGL1_003')
landc <- ee$ImageCollection('MODIS/006/MCD12Q1')
vias_dep <- ee$FeatureCollection('users/edgarmanrique30/Peru_geometry/red_vial_departamental_dic16')
vias_nac <- ee$FeatureCollection('users/edgarmanrique30/Peru_geometry/red_vial_nacional_dic16')
vias_vec <- ee$FeatureCollection('users/edgarmanrique30/Peru_geometry/red_vial_vecinal_dic16')
rios  <- ee$Image('WWF/HydroSHEDS/15ACC')
anp   <- ee$FeatureCollection('users/edgarmanrique30/Peru_geometry/ANP-Nacional')
inputPoints <- ee$FeatureCollection('users/edgarmanrique30/Peru_geometry/eess_20190319')
# Construccion our friction surface
# Topographyc variables
dem <- dem$clip(peru)
slope <- ee$Terrain$slope(dem)
# LandCover for Peru
landc <- landc$select("LC_Type1")$
filterDate("2017-01-01","2017-12-31")$
median()$
clip(peru)
Map.addLayer(landc)
Map$addLayer(landc)
# Hydrology variables
peru_rios <- peru$
filter(ee$Filter$inList('NOMBDEP',c("LORETO", "MADRE DE DIOS", "UCAYALI")))
Map$addLayer(peru_rios)
rios <- rios$gt(5000)
Map$addLayer(rios)
rios <- rios$remap(c(0,1),c(0,9))
Map$addLayer(rios)
Map$addLayer(black)
vias_nac <- black$paint(vias_nac, 80)$clip(peru$geometry())
Map$addLayer(vias_nac)
Map$addLayer(vias_dep)
black <- ee$Image(0)$byte()
vias_dep <- ee$FeatureCollection('users/edgarmanrique30/Peru_geometry/red_vial_departamental_dic16')
vias_nac <- ee$FeatureCollection('users/edgarmanrique30/Peru_geometry/red_vial_nacional_dic16')
vias_vec <- ee$FeatureCollection('users/edgarmanrique30/Peru_geometry/red_vial_vecinal_dic16')
vias_nac <- black$paint(vias_nac, 80)$clip(peru$geometry())
Map$addLayer(vias_nac)
vias_dep <- black$paint(vias_dep, 50)$clip(peru$geometry())
Map$addLayer(vias_dep)
vias_vec <- black$paint(vias_vec, 30)$clip(peru$geometry())
Map$addLayer(vias_vec)
# LC_Type1, Remapping the pixel values of each category of land cover to their respective speed in km/h.
landcspeed <- landc$
remap(c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 ,14, 15, 16, 17),
c(3.24, 1.62, 3.24, 4, 3.24, 3, 4.2, 4.86, 4.86, 4.86, 2, 2.5, 5, 3.24, 1.62, 3, 1))
Map$addLayer(landcspeed)
# Filtering urban areas to multiply the roads speed by .7
landc_urban <- landc$eq(13)
Map$addLayer(landc_urban)
# Filtering urban areas to multiply the roads speed by .7
landc_urban <- landc_urban$remap(c(0,1),c(1,0.7))
Map$addLayer(landc_urban)
vias_nac <- vias_nac$multiply(landc_urban) # Multiplying roads layers by 0.7 in urban areas
Map$addLayer(vias_nac)
Map$addLayer(vias_dep)
Map$addLayer(vias_vec)
Map$addLayer(anp)
anp
# Creating Natural protected areas layer
black <- ee$Image(0)$byte();
anp <- black$paint(anp, 1)$clip(peru$geometry())
Map$addLayer(anp)
#Remapping values to 0.2 km/h of Natural protected areas to multiply Landcover speed
anp <- anp$remap(list(0,1),list(1,0.2))
Map$addLayer(anp)
Map$addLayer(landcspeed)
landcspeed <- landcspeed$multiply(anp) # Multiplying Landcover speed by 0.2 on Natural protected areas
Map$addLayer(landcspeed)
landcspeed <- landcspeed$toDouble()$select(list(0),list("speed"))
Map$addLayer(landcspeed)
rios <- rios$toDouble()$select(list(0),list("speed"))
Map$addLayer(rios)
Map$addLayer(vias_nac)
Map$addLayer(vias_dep)
Map$addLayer(vias_vec)
Map$addLayer(vias_nac)
vias_nac <- vias_nac$toDouble()$select(list(0),list("speed")) # unifying the band name
vias_dep <- vias_dep$toDouble()$select(list(0),list("speed")) # unifying the band name
vias_vec <- vias_vec$toDouble()$select(list(0),list("speed")) # unifying the band name
# Mergging all layers into a collection
collection <- ee$ImageCollection(
list(landcspeed,
rios,
vias_nac,
vias_dep,
vias_vec
)
)
fsurface <- collection$max() # Calculating the maximum value of speed on a single pixel
Map$addLayer(fsurface)
# eaf <- function(x) {1.01*exp(-0.0001072*x)} # Elevation adjustment factor
eaf <- dem$expression(
c('1.01*exp(-0.0001072*DEM)'),list(
'DEM'= dem$select('elevation')))
Map$addLayer(eaf)
# thf <- function(x) {6*exp(-3.5*abs((tan(x/57.296) + 0.05)))/5} # Tobler's hikking function adjustment
thf <- slope$expression(
c('6*exp(-3.5*abs((tan(slope/57.296) + 0.05)))/5'), list(
'slope'= slope$select(list(0))
))
Map$addLayer(thf)
# Adjusting the friction surface by EAF and THF
fsurface <- fsurface$multiply(eaf)$multiply(thf)
Map.addLayer(fsurface)
Map$addLayer(fsurface)
# convert <- function(x) {(x * 1000 / 60) ^ -1} # converts km/h to min/m
fsurface <- fsurface$expression(
c('(x * 1000 / 60) ** -1'),
list('x'= fsurface$select(list(0)))
)
Map$addLayer(fsurface)
# Paint the input points, essentially converting them to a raster.
# Theoretically this will merge any points that fall within the same pixel (of the resulting 30-arc-second resolution).
black <- ee$Image(0)$byte()
sources <- black$paint(inputPoints, 1)
sources <- sources$updateMask(sources)
Map$addLayer(sources)
# Compute the min cost path distance map, with a horizon of 1500 km.
# This can be reduced for high-latitude areas and/or to shorten processing time.
distance <- fsurface$cumulativeCost(sources, 400000)  # The function accepts meters rather than km.
Map$addLayer(distance)
sources
# Paint the input points, essentially converting them to a raster.
# Theoretically this will merge any points that fall within the same pixel (of the resulting 30-arc-second resolution).
black <- ee$Image(0)$byte()
sources <- black$paint(inputPoints, 1)
sources <- sources$updateMask(sources)
# Compute the min cost path distance map, with a horizon of 1500 km.
# This can be reduced for high-latitude areas and/or to shorten processing time.
distance <- fsurface$cumulativeCost(sources, 400000)  # The function accepts meters rather than km.
Map$addLayer(distance)
distance
distance <- distance$toInt() # Here we convert the output to integer to make the output .tif smaller (and the code more likely to run successfully).
distance
Map$addLayer(distance)
Map$addLayer(distance)
distance <- distance$clip(peru)
Map$addLayer(distance)
# Final Map
viz <- list(
min = 0,
max = 600,
palette = c("#dd554b","#e2b43f","#dbda92","#60b27f","#4866c9")
)
Map$addLayer(distance,viz,'accessibility') +
Map$addLayer(fsurface$clip(peru),viz,'friction')
setwd("~/Documentos/GitHub/ClimateStripes4PE/docs")
#### ANCASH
#### ANCASH
#### ANCASH
#### ANCASH
#### ANCASH
#### ANCASH
#### ANCASH
#### ANCASH
#### ANCASH
#### ANCASH
#### ANCASH
#### ANCASH
#### ANCASH
#### MADRE DE DIOS
#### MADRE DE DIOS
#### MADRE DE DIOS
#### MADRE DE DIOS
#### MADRE DE DIOS
#### MADRE DE DIOS
#### MADRE DE DIOS
1980 - 2022
## Global options
knitr::opts_chunk$set(cache = TRUE)
library(tidyverse)
library(tidyverse)
library(cptcity)
library(plotly)
data <- read_rds("data/temp")
library(tidyverse)
library(cptcity)
library(plotly)
data <- read_rds("data/temp")
tidydata <- temp %>%
pivot_longer(cols = `tmmx1958-01`:`tmmx2020-11`) %>%
mutate(
dep = case_when(
dep == "CALLAO" ~ "LIMA",
dep != "CALLAO" ~ dep
)
) %>%
mutate(fecha = substr(name, 5, 8)) %>%
mutate(
year = as.integer(substr(fecha, 1, 4)),
temp = as.double(value)
) %>%
select(dep, year, temp) %>%
mutate(dep = factor(dep)) %>%
group_by(dep, year) %>%
summarise(temp = mean(temp))
data
library(tidyverse)
library(cptcity)
library(plotly)
data <- read_rds("data/temp")
tidydata <- temp %>%
pivot_longer(cols = `tmmx1958-01`:`tmmx2020-11`) %>%
mutate(
dep = case_when(
dep == "CALLAO" ~ "LIMA",
dep != "CALLAO" ~ dep
)
) %>%
mutate(fecha = substr(name, 5, 8)) %>%
mutate(
year = as.integer(substr(fecha, 1, 4)),
temp = as.double(value)
) %>%
select(dep, year, temp) %>%
mutate(dep = factor(dep)) %>%
group_by(dep, year) %>%
summarise(temp = mean(temp))
library(tidyverse)
library(cptcity)
library(plotly)
temp <- read_rds("data/temp")
tidydata <- temp %>%
pivot_longer(cols = `tmmx1958-01`:`tmmx2020-11`) %>%
mutate(
dep = case_when(
dep == "CALLAO" ~ "LIMA",
dep != "CALLAO" ~ dep
)
) %>%
mutate(fecha = substr(name, 5, 8)) %>%
mutate(
year = as.integer(substr(fecha, 1, 4)),
temp = as.double(value)
) %>%
select(dep, year, temp) %>%
mutate(dep = factor(dep)) %>%
group_by(dep, year) %>%
summarise(temp = mean(temp))
temp_ref <- tidydata %>%
filter(year == 1980) %>%
select(temp)
names <- tidydata %>% select(dep) %>% unique()
ref <- temp_ref %>% filter(dep == names[[1]][i]) %>%
select(temp) %>% pull()
ref <- temp_ref %>% filter(dep == "AMAZONAS") %>%
select(temp) %>% pull()
ref
data %>%
ggplot(aes(x = year,y = 1, fill = temp)) +
geom_tile() +
scale_fill_gradientn(
colors = cpt(pal = "cb_div_RdBu_05",n = 5,rev = T),
na.value = "transparent"
) +
theme_void() +
labs(
subtitle = "(1958-2020)",
caption = "Source: Elaborado por Pendulum-Lab con datos de TerraClim"
) +
labs(title = "AMAZONAS")
data
ref <- temp_ref %>% filter(dep == "AMAZONAS") %>%
select(temp) %>% pull()
data <- tidydata %>% filter(dep == "AMAZONAS") %>%
mutate(temp = temp)
p1 <- data %>%
ggplot(aes(x = year,y = 1, fill = temp)) +
geom_tile() +
scale_fill_gradientn(
colors = cpt(pal = "cb_div_RdBu_05",n = 5,rev = T),
na.value = "transparent"
) +
theme_void() +
labs(
subtitle = "(1958-2020)",
caption = "Source: Elaborado por Pendulum-Lab con datos de TerraClim"
) +
labs(title = "AMAZONAS")
p1
ref <- temp_ref %>% filter(dep == "AMAZONAS") %>%
select(temp) %>% pull()
data <- tidydata %>% filter(dep == "AMAZONAS") %>%
mutate(temp = temp)
p1 <- data %>%
ggplot(aes(x = year,y = 1, fill = temp)) +
geom_tile() +
scale_fill_gradientn(
colors = cpt(pal = "cb_div_RdBu_05",n = 5,rev = T),
na.value = "transparent"
) +
theme_void() +
labs(
subtitle = "(1958-2020)",
caption = "Source: Elaborado por Pendulum-Lab con datos de TerraClim"
) +
labs(title = "AMAZONAS")
ggplotly(p1)
ref <- temp_ref %>% filter(dep == "AMAZONAS") %>%
select(temp) %>% pull()
data <- tidydata %>% filter(dep == "AMAZONAS") %>%
mutate(temp = temp)
p1 <- data %>%
ggplot(aes(x = year,y = 1, fill = temp)) +
geom_tile() +
scale_fill_gradientn(
colors = cpt(pal = "cb_div_RdBu_05",n = 5,rev = T),
na.value = "transparent"
) +
theme_void() +
labs(
subtitle = "(1958-2020)",
caption = "Source: Elaborado por Pendulum-Lab con datos de TerraClim"
) +
labs(title = "AMAZONAS")
ggplotly(p1)
ref <- temp_ref %>% filter(dep == "AMAZONAS") %>%
select(temp) %>% pull()
data <- tidydata %>% filter(dep == "AMAZONAS") %>%
mutate(temp = temp)
p1 <- data %>%
ggplot(aes(x = year,y = 1, fill = temp)) +
geom_tile() +
scale_fill_gradientn(
colors = cpt(pal = "cb_div_RdBu_05",n = 5,rev = T),
na.value = "transparent"
) +
theme_void() +
labs(
subtitle = "(1958-2020)",
caption = "Source: Elaborado por Pendulum-Lab con datos de TerraClim"
) +
labs(title = "AMAZONAS")
ggplotly(p1)
ref <- temp_ref %>% filter(dep == "AMAZONAS") %>%
select(temp) %>% pull()
data <- tidydata %>% filter(dep == "AMAZONAS") %>%
mutate(temp = temp)
p1 <- data %>%
ggplot(aes(x = year,y = 1, fill = temp)) +
geom_tile() +
scale_fill_gradientn(
colors = cpt(pal = "cb_div_RdBu_05",n = 5,rev = T),
na.value = "transparent"
) +
theme_void() +
labs(
subtitle = "(1958-2020)",
caption = "Source: Elaborado por Pendulum-Lab con datos de TerraClim"
) +
labs(title = "AMAZONAS")
ggplotly(p1)
